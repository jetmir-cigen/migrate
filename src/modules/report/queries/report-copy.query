import {
  QueryHandlerInterface,
  QueryInterface,
} from '@/common/query.interface';
import { DataSource, Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { QueryHandler } from '@nestjs/cqrs';
import { DPOrderDownPaymentEntity } from '../entities/device_policy.order_down_payment.entity';
import { EOrderDownPaymentEntity } from '../entities/ecom.order_down_payment.entity';
import { CustomerSetupExportSettingsEntity } from '../entities/customer-setup-export-settings.entity';
import { CostObjectEntity } from '@/common/entities/cost-object.entity';
import { CustomerEntity } from '@/modules/customer/entities/customer.entity';
import { DPOrderEntity } from '../entities/device_policy.order.entity';
import { DPProductEntity } from '../entities/device_policy.product.entity';
import { DepartmentEntity } from '@/modules/department/entities/department.entity';
import { EOrderEntity } from '../entities/ecom.order.entity';
import { AAssetEntity } from '../entities/assets.asset.entity';

export class ReportQuery implements QueryInterface {
  $$resolveType: any;

  constructor(public readonly customerId: number) {}
}

@QueryHandler(ReportQuery)
export class ReportQueryHandler implements QueryHandlerInterface<ReportQuery> {
  constructor(
    @InjectRepository(DPOrderDownPaymentEntity)
    private readonly DPOrderDownPaymentRepository: Repository<DPOrderDownPaymentEntity>,
    @InjectRepository(EOrderDownPaymentEntity)
    private readonly EOrderDownPaymentEntityRepository: Repository<EOrderDownPaymentEntity>,
    private dataSource: DataSource,
  ) {}

  async execute(query: ReportQuery): Promise<any> {
    const customerId = 1; // Replace with the actual customer ID
    const customerHeadId = 1; // Replace with the actual customer head ID
    const fromDate = '2023-01-01'; // Replace with the actual start date
    const toDate = '2023-12-31'; // Replace with the actual end date

    const queryBuilder1 = this.dataSource
      .createQueryBuilder()
      .select([
        'co.name',
        'co.employee_no',
        'co.dim_1',
        'co.code AS phone_no',
        'co.accounting_code AS co_accounting_code',
        'd.code AS department_code',
        'd.name AS department_name',
        'product.model',
        'dpod.payment_date',
        'dpo.order_date',
        'dpo.order_update',
        'dpo.delivery_date',
        'dpo.down_payments',
        'dpo.total_amount',
        'dpo.total_amount - dpo.remainder_amount AS cover_amount',
        'dpod.amount',
        'dpod.is_buyout',
        'c.name AS customer_name',
        'c.id AS customer_id',
        'c.customer_head_id',
      ])
      .from(DPOrderDownPaymentEntity, 'dpod')
      .leftJoin(CostObjectEntity, 'co', 'dpod.cost_object_id = co.id')
      .innerJoin(CustomerEntity, 'c', 'c.id = co.customer_id')
      .leftJoin(DPOrderEntity, 'dpo', 'dpod.order_id = dpo.id')
      .leftJoin(DPProductEntity, 'product', 'dpo.product_id = product.id')
      .leftJoin(DepartmentEntity, 'd', 'd.id = co.department_id')
      .where('c.id = :customerId OR c.customer_head_id = :customerHeadId', {
        customerId,
        customerHeadId,
      })
      .andWhere('DATE(dpod.payment_date) >= :fromDate', { fromDate })
      .andWhere('DATE(dpod.payment_date) <= :toDate', { toDate });

    const queryBuilder2 = this.dataSource
      .createQueryBuilder()
      .select([
        'co.name',
        'co.employee_no',
        'co.dim_1',
        'co.code AS phone_no',
        'co.accounting_code AS co_accounting_code',
        'd.code',
        'd.name AS department_name',
        'a.asset_description AS model',
        'odp.date AS payment_date',
        'o.order_date',
        'o.updated AS order_update',
        'o.DeliveredDate AS delivery_date',
        'o.down_payments',
        'o.cover_amount + o.remainder_amount AS total_amount',
        'o.cover_amount',
        'odp.amount',
        'odp.is_buyout',
        'c.name AS customer_name',
        'c.id AS customer_id',
        'c.customer_head_id',
      ])
      .from(EOrderDownPaymentEntity, 'odp')
      .leftJoin(CostObjectEntity, 'co', 'odp.cost_object_id = co.id')
      .innerJoin(CustomerEntity, 'c', 'c.id = co.customer_id')
      .leftJoin(DepartmentEntity, 'd', 'd.id = co.department_id')
      .leftJoin(EOrderEntity, 'o', 'odp.order_id = o.id')
      .leftJoin(AAssetEntity, 'a', 'a.id = odp.asset_id')
      .where('c.id = :customerId OR c.customer_head_id = :customerHeadId', {
        customerId,
        customerHeadId,
      })
      .andWhere('odp.is_active = 1')
      .andWhere('DATE(odp.date) >= :fromDate', { fromDate })
      .andWhere('DATE(odp.date) <= :toDate', { toDate })
      .groupBy('odp.id');

    const allQueries = [queryBuilder1, queryBuilder2];

    const sqlQueries = allQueries.map((b) => b.getQuery());

    // Merge all the parameters from the other queries into a single object. You'll need to make sure that all your parameters have unique names
    const sqlParameters = allQueries
      .map((b) => b.getParameters())
      .reduce((prev, curr) => ({ ...prev, ...curr }), {});

    // Join all your queries into a single SQL string
    const unionedQuery = '(' + sqlQueries.join(') UNION (') + ')';

    // const fullQuery = `(${query1}) UNION (${query2})`;

    // (query1) UNION (query2)

    const final = this.dataSource
      .createQueryBuilder()
      .select([
        'down_payment.name',
        'down_payment.employee_no',
        'down_payment.phone_no',
        'down_payment.dim_1',
        'down_payment.co_accounting_code',
        'down_payment.department_code',
        'down_payment.department_name',
        'down_payment.model',
        `IF(down_payment.is_buyout = 1, DATE_FORMAT(down_payment.payment_date, '%Y-%m-%d'), DATE_FORMAT(down_payment.order_date, '%Y-%m-%d'))`,
        `DATE_FORMAT(down_payment.order_update, '%Y-%m-%d')`,
        'down_payment.delivery_date',
        'down_payment.down_payments',
        'down_payment.cover_amount',
        'AVG(down_payment.total_amount - down_payment.cover_amount)',
        'AVG(down_payment.total_amount)',
        'SUM(down_payment.amount)',
        'down_payment.is_buyout',
        'down_payment.customer_id',
        'down_payment.customer_name',
        'down_payment.customer_head_id',
        `IF(down_payment.is_buyout = 1 AND cse.salary_deduction_code_buyout IS NOT NULL, cse.salary_deduction_code_buyout, cse.salary_deduction_code_device)`,
        'cse.project_device',
        'cse.department_override_device',
      ])
      .from(unionedQuery, 'down_payment')
      .leftJoinAndSelect(
        CustomerSetupExportSettingsEntity,
        'cse',
        'down_payment.customer_id = cse.customer_id',
      )
      .groupBy('down_payment.name')
      .addGroupBy('down_payment.employee_no')
      .addGroupBy('down_payment.department_code')
      .addGroupBy('down_payment.department_name')
      .addGroupBy('down_payment.order_date')
      .addGroupBy('down_payment.order_update')
      .addGroupBy('down_payment.delivery_date')
      .addGroupBy('down_payment.total_amount')
      .addGroupBy('down_payment.cover_amount')
      .addGroupBy('down_payment.down_payments')
      .addGroupBy('down_payment.is_buyout')
      .addGroupBy('down_payment.model')
      .orderBy('down_payment.name');

    final.expressionMap.mainAlias.metadata = final.connection.getMetadata(
      DPOrderDownPaymentEntity,
    );
    // console.log({ final: final.getQuery() });
    console.log('TEST', { sqlParameters });

    const result = await final.setParameters(sqlParameters).getMany();

    console.log({ result });

    return result;
  }
}
